<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TriFid —Å –∞—Ñ–∏–Ω–Ω—ã–º –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ–º –∏ CBC</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #333; }
        .container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .panel { background: rgba(255, 255, 255, 0.95); padding: 20px; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); backdrop-filter: blur(10px); }
        h1 { text-align: center; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); margin-bottom: 30px; }
        h2, h3 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
        textarea, input[type="text"], button, select { 
            width: 100%; padding: 12px; margin: 10px 0; border: 2px solid #ddd; border-radius: 8px; box-sizing: border-box;
            font-size: 16px; transition: all 0.3s ease; 
        }
        textarea { 
            height: 120px; font-family: 'Courier New', monospace; background: #f8f9fa; 
            border: 2px solid #3498db; 
        }
        textarea:focus, input:focus { 
            border-color: #e74c3c; outline: none; box-shadow: 0 0 10px rgba(231, 76, 60, 0.3); 
        }
        button { 
            background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; border: none; padding: 15px; 
            cursor: pointer; font-weight: bold; font-size: 18px; text-transform: uppercase; letter-spacing: 1px;
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4); 
        }
        button:hover { 
            transform: translateY(-2px); box-shadow: 0 8px 20px rgba(231, 76, 60, 0.6); 
        }
        button:active { transform: translateY(0); }
        .visualization { 
            margin-top: 20px; padding: 20px; background: linear-gradient(135deg, #74b9ff, #0984e3); 
            border-radius: 10px; color: white; border: 2px solid #dfe6e9;
        }
        .box-container { 
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; 
        }
        .box-grid { 
            display: grid; grid-template-columns: repeat(17, 1fr); gap: 2px; background: white; padding: 10px;
            border-radius: 8px; border: 3px solid #2d3436; box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .box-header { 
            text-align: center; font-weight: bold; padding: 5px; background: #2d3436; color: white;
            font-size: 12px; display: flex; align-items: center; justify-content: center;
        }
        .box-cell { 
            padding: 5px; text-align: center; background: #dfe6e9; border: 1px solid #b2bec3;
            font-size: 11px; font-weight: bold; min-height: 25px; display: flex; align-items: center; justify-content: center;
        }
        .highlight { 
            background: #ffeaa7 !important; border: 2px solid #fdcb6e !important; color: #2d3436; 
            box-shadow: 0 0 10px rgba(253, 203, 110, 0.8); 
        }
        .status { 
            padding: 15px; margin: 15px 0; border-radius: 8px; display: none; font-weight: bold;
            border: 2px solid transparent; 
        }
        .success { background: rgba(39, 174, 96, 0.2); color: #27ae60; border-color: #27ae60; }
        .error { background: rgba(231, 76, 60, 0.2); color: #e74c3c; border-color: #e74c3c; }
        .processing { background: rgba(52, 152, 219, 0.2); color: #3498db; border-color: #3498db; }
        .hex-view { 
            font-family: 'Courier New', monospace; word-break: break-all; background: #2d3436; 
            padding: 15px; border-radius: 8px; margin: 15px 0; color: #00cec9; font-size: 14px;
            border: 2px solid #00cec9; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .formula { 
            background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;
            border: 2px solid #fd79a8; color: #fd79a8; font-family: 'Courier New', monospace;
        }
        .operation-log { 
            max-height: 200px; overflow-y: auto; background: rgba(45, 52, 54, 0.9); padding: 15px;
            border-radius: 8px; margin: 15px 0; color: #00cec9; font-family: 'Courier New', monospace;
            font-size: 12px; border: 2px solid #6c5ce7;
        }
        @media (max-width: 768px) {
            .container { grid-template-columns: 1fr; }
            .box-container { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <h1>üöÄ TriFid —Å –∞—Ñ–∏–Ω–Ω—ã–º –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ–º –∏ CBC</h1>

    <div class="container">
        <div class="panel">
            <h2>üîí –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</h2>
            <input type="text" id="encryptKey" placeholder="–ö–ª—é—á–µ–≤–∞—è —Ñ—Ä–∞–∑–∞" value="—Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á">
            <textarea id="plainText" placeholder="–¢–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è">–ü—Ä–∏–º–µ—Ä —Ç–µ–∫—Å—Ç–∞ –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</textarea>
            <select id="encryptMode">
                <option value="cbc">CBC —Ä–µ–∂–∏–º (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)</option>
                <option value="ecb">ECB —Ä–µ–∂–∏–º (–±–µ–∑ –∑–∞—â–∏—Ç—ã)</option>
            </select>
            <button onclick="encrypt()">üîÑ –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            <div id="encryptStatus" class="status"></div>
            <div class="hex-view">–®–∏—Ñ—Ä–æ—Ç–µ–∫—Å—Ç (HEX): <span id="cipherHex"></span></div>
        </div>

        <div class="panel">
            <h2>üîì –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</h2>
            <input type="text" id="decryptKey" placeholder="–ö–ª—é—á–µ–≤–∞—è —Ñ—Ä–∞–∑–∞" value="—Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á">
            <textarea id="cipherText" placeholder="–®–∏—Ñ—Ä–æ—Ç–µ–∫—Å—Ç –≤ HEX —Ñ–æ—Ä–º–∞—Ç–µ"></textarea>
            <select id="decryptMode">
                <option value="cbc">CBC —Ä–µ–∂–∏–º</option>
                <option value="ecb">ECB —Ä–µ–∂–∏–º</option>
            </select>
            <button onclick="decrypt()">üîÑ –î–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            <div id="decryptStatus" class="status"></div>
            <div class="hex-view">–†–µ–∑—É–ª—å—Ç–∞—Ç: <span id="decryptedText"></span></div>
        </div>
    </div>

    <div class="panel">
        <h2>üìä –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π</h2>
        <p>–¢–µ–∫—É—â–∏–π –∫–ª—é—á: <strong id="currentKey">—Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á</strong></p>
        <button onclick="updateVisualization()">üîÑ –û–±–Ω–æ–≤–∏—Ç—å –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é</button>

        <div class="formula">
            <strong>–§–æ—Ä–º—É–ª–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:</strong><br>
            r = (P_i >> 4) ^ (C_{i-1} & 0x0F) ^ (i & 0x0F)<br>
            c = (P_i & 0x0F) ^ ((C_{i-1} >> 4) & 0x0F) ^ ((i >> 4) & 0x0F)<br>
            a = (r * 11 + c * 7) % 16, b = (c * 13 + r * 5) % 16<br>
            C_i = (box[15-a][b] << 4) | box[a][15-b]
        </div>

        <div class="box-container">
            <div>
                <h3>üì¶ –ë–æ–∫—Å –∑–∞–º–µ–Ω—ã (–Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞)</h3>
                <div id="boxVisualization" class="box-grid"></div>
            </div>
            <div>
                <h3>üìà –ü–æ—Å–ª–µ–¥–Ω—è—è –æ–ø–µ—Ä–∞—Ü–∏—è</h3>
                <div id="operationVisualization" class="visualization">
                    <p>–í—ã–ø–æ–ª–Ω–∏—Ç–µ –æ–ø–µ—Ä–∞—Ü–∏—é –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –¥–µ—Ç–∞–ª–µ–π</p>
                </div>
                <div class="operation-log" id="operationLog"></div>
            </div>
        </div>
    </div>

    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let currentBox = null;
        let currentKey = "";
        let operationLog = [];

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.onload = function() {
            updateVisualization();
        };

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –±–æ–∫—Å–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞
        function createBoxFromKey(key) {
            if (key === currentKey && currentBox !== null) {
                return currentBox;
            }
            
            currentKey = key;
            const box = new Array(16);
            
            // –°–æ–∑–¥–∞–µ–º –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π seed –∏–∑ –∫–ª—é—á–∞
            const encoder = new TextEncoder();
            const keyData = encoder.encode(key);
            const seed = new Uint8Array(32);
            
            for (let i = 0; i < keyData.length; i++) {
                seed[i % 32] ^= keyData[i];
            }
            
            // –ó–∞–ø–æ–ª–Ω—è–µ–º –±–æ–∫—Å –Ω–∞—á–∞–ª—å–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
            const tempArray = new Array(256);
            for (let i = 0; i < 256; i++) {
                tempArray[i] = i;
            }
            
            // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º using Fisher-Yates
            for (let i = 255; i > 0; i--) {
                const j = (seed[i % 32] + seed[(i + 7) % 32] * 256) % (i + 1);
                [tempArray[i], tempArray[j]] = [tempArray[j], tempArray[i]];
            }
            
            // –ó–∞–ø–æ–ª–Ω—è–µ–º 16x16 –±–æ–∫—Å
            for (let i = 0; i < 16; i++) {
                box[i] = new Array(16);
                for (let j = 0; j < 16; j++) {
                    box[i][j] = tempArray[i * 16 + j];
                }
            }
            
            currentBox = box;
            return box;
        }

        // –ê—Ñ–∏–Ω–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ (–ø—Ä—è–º–æ–µ)
        function affineTransform(r, c) {
            const a = (r * 11 + c * 7) % 16;
            const b = (c * 13 + r * 5) % 16;
            return { a, b };
        }

        // –û–±—Ä–∞—Ç–Ω–æ–µ –∞—Ñ–∏–Ω–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
        function inverseAffine(a, b) {
            // –†–µ—à–∞–µ–º —Å–∏—Å—Ç–µ–º—É —É—Ä–∞–≤–Ω–µ–Ω–∏–π:
            // 11r + 7c ‚â° a mod 16
            // 5r + 13c ‚â° b mod 16
            const det = (11 * 13 - 7 * 5) % 16; // 143 - 35 = 108 ‚â° 12 mod 16
            const detInv = [0,1,0,11,0,13,0,7,0,9,0,3,0,15,0,5][det]; // 12‚Åª¬π mod 16 = –Ω–µ—Ç, —Ç.–∫. 12 –∏ 16 –Ω–µ –≤–∑–∞–∏–º–Ω–æ –ø—Ä–æ—Å—Ç—ã
            
            if (detInv === 0) {
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–µ–±–æ—Ä –µ—Å–ª–∏ –º–∞—Ç—Ä–∏—Ü–∞ –≤—ã—Ä–æ–∂–¥–µ–Ω–∞
                for (let r = 0; r < 16; r++) {
                    for (let c = 0; c < 16; c++) {
                        const res = affineTransform(r, c);
                        if (res.a === a && res.b === b) {
                            return { r, c };
                        }
                    }
                }
                return { r: 0, c: 0 };
            }
            
            const r = (13 * a - 7 * b) * detInv % 16;
            const c = (-5 * a + 11 * b) * detInv % 16;
            return { r: (r + 16) % 16, c: (c + 16) % 16 };
        }

        // –§—É–Ω–∫—Ü–∏—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –±–∞–π—Ç–∞
        function encryptByte(byte, box, position, prevCipher) {
            const mode = document.getElementById('encryptMode').value;
            
            // –†–∞–∑–±–∏–≤–∞–µ–º –±–∞–π—Ç –Ω–∞ –ø–æ–ª—É–±–∞–π—Ç—ã
            let r = (byte >> 4) & 0x0F;
            let c = byte & 0x0F;
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –æ—Ç –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –±–∞–π—Ç–∞ –∏ –ø–æ–∑–∏—Ü–∏–∏
            if (mode === 'cbc') {
                r = r ^ (prevCipher & 0x0F) ^ (position & 0x0F);
                c = c ^ ((prevCipher >> 4) & 0x0F) ^ ((position >> 4) & 0x0F);
            }
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –∞—Ñ–∏–Ω–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
            const { a, b } = affineTransform(r, c);
            
            // –ë–µ—Ä—ë–º –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ –±–æ–∫—Å–∞ —Å –∏–Ω–≤–µ—Ä—Å–∏–µ–π –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
            const B = box[(16 - a) % 16][b];
            const C_val = box[a][(16 - b) % 16];
            
            // –§–æ—Ä–º–∏—Ä—É–µ–º –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π –±–∞–π—Ç
            const encrypted = (B << 4) | (C_val & 0x0F);
            
            return {
                original: byte,
                encrypted: encrypted,
                r, c, a, b,
                B, C_val,
                position: position,
                prevCipher: prevCipher
            };
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –±–∞–π—Ç–∞
        function decryptByte(byte, box, position, prevCipher) {
            const mode = document.getElementById('decryptMode').value;
            
            // –†–∞–∑–±–∏–≤–∞–µ–º –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π –±–∞–π—Ç
            const targetB = (byte >> 4) & 0x0F;
            const targetC = byte & 0x0F;
            
            // –ò—â–µ–º a –∏ b —Ç–∞–∫–∏–µ, —á—Ç–æ:
            // box[15-a][b] == targetB –∏ box[a][15-b] == targetC
            for (let a = 0; a < 16; a++) {
                for (let b = 0; b < 16; b++) {
                    if (box[(16 - a) % 16][b] === targetB && box[a][(16 - b) % 16] === targetC) {
                        // –ù–∞—à–ª–∏ a –∏ b, –ø—Ä–∏–º–µ–Ω—è–µ–º –æ–±—Ä–∞—Ç–Ω–æ–µ –∞—Ñ–∏–Ω–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
                        const { r, c } = inverseAffine(a, b);
                        
                        let originalR = r;
                        let originalC = c;
                        
                        // –£–±–∏—Ä–∞–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –æ—Ç –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –±–∞–π—Ç–∞ –∏ –ø–æ–∑–∏—Ü–∏–∏
                        if (mode === 'cbc') {
                            originalR = r ^ (prevCipher & 0x0F) ^ (position & 0x0F);
                            originalC = c ^ ((prevCipher >> 4) & 0x0F) ^ ((position >> 4) & 0x0F);
                        }
                        
                        const original = (originalR << 4) | originalC;
                        
                        return {
                            encrypted: byte,
                            original: original,
                            r, c, a, b,
                            originalR, originalC,
                            position: position,
                            prevCipher: prevCipher
                        };
                    }
                }
            }
            
            return null;
        }

        // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
        function encrypt() {
            const key = document.getElementById('encryptKey').value;
            const text = document.getElementById('plainText').value;
            
            if (!key || !text) {
                showStatus('encryptStatus', 'error', '–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á –∏ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                return;
            }
            
            showStatus('encryptStatus', 'processing', '–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ...');
            operationLog = [];
            
            setTimeout(() => {
                try {
                    const box = createBoxFromKey(key);
                    const encoder = new TextEncoder();
                    const data = encoder.encode(text);
                    const result = new Uint8Array(data.length);
                    let prevCipher = 0x55; // Initialization Vector
                    
                    for (let i = 0; i < data.length; i++) {
                        const detail = encryptByte(data[i], box, i, prevCipher);
                        result[i] = detail.encrypted;
                        prevCipher = detail.encrypted;
                        operationLog.push(detail);
                    }
                    
                    const hexResult = Array.from(result).map(b => b.toString(16).padStart(2, '0')).join('');
                    document.getElementById('cipherText').value = hexResult;
                    document.getElementById('cipherHex').textContent = hexResult;
                    
                    showStatus('encryptStatus', 'success', `–£—Å–ø–µ—à–Ω–æ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ ${data.length} –±–∞–π—Ç`);
                    visualizeOperation(operationLog[0], 'encrypt');
                    updateOperationLog();
                } catch (error) {
                    showStatus('encryptStatus', 'error', '–û—à–∏–±–∫–∞ –ø—Ä–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏: ' + error.message);
                }
            }, 100);
        }

        // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
        function decrypt() {
            const key = document.getElementById('decryptKey').value;
            const cipherHex = document.getElementById('cipherText').value;
            
            if (!key || !cipherHex) {
                showStatus('decryptStatus', 'error', '–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á –∏ —à–∏—Ñ—Ä–æ—Ç–µ–∫—Å—Ç');
                return;
            }
            
            if (!/^[0-9a-fA-F]+$/.test(cipherHex) || cipherHex.length % 2 !== 0) {
                showStatus('decryptStatus', 'error', '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç HEX –¥–∞–Ω–Ω—ã—Ö');
                return;
            }
            
            showStatus('decryptStatus', 'processing', '–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ...');
            operationLog = [];
            
            setTimeout(() => {
                try {
                    const box = createBoxFromKey(key);
                    const byteArray = [];
                    for (let i = 0; i < cipherHex.length; i += 2) {
                        byteArray.push(parseInt(cipherHex.substr(i, 2), 16));
                    }
                    
                    const result = new Uint8Array(byteArray.length);
                    let prevCipher = 0x55; // –¢–æ—Ç –∂–µ IV
                    
                    for (let i = 0; i < byteArray.length; i++) {
                        const detail = decryptByte(byteArray[i], box, i, prevCipher);
                        if (detail === null) {
                            throw new Error(`–ù–µ —É–¥–∞–ª–æ—Å—å –¥–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å –±–∞–π—Ç –Ω–∞ –ø–æ–∑–∏—Ü–∏–∏ ${i}`);
                        }
                        result[i] = detail.original;
                        prevCipher = byteArray[i];
                        operationLog.push(detail);
                    }
                    
                    const decoder = new TextDecoder();
                    const textResult = decoder.decode(result);
                    document.getElementById('decryptedText').textContent = textResult;
                    
                    showStatus('decryptStatus', 'success', `–£—Å–ø–µ—à–Ω–æ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ ${byteArray.length} –±–∞–π—Ç`);
                    visualizeOperation(operationLog[0], 'decrypt');
                    updateOperationLog();
                } catch (error) {
                    showStatus('decryptStatus', 'error', '–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏: ' + error.message);
                }
            }, 100);
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞
        function showStatus(elementId, type, message) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = 'status ' + type;
            element.style.display = 'block';
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –±–æ–∫—Å–∞
        function updateVisualization() {
            const key = document.getElementById('encryptKey').value || document.getElementById('decryptKey').value || '—Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á';
            document.getElementById('currentKey').textContent = key;
            
            const box = createBoxFromKey(key);
            const container = document.getElementById('boxVisualization');
            container.innerHTML = '';
            
            // –ó–∞–≥–æ–ª–æ–≤–∫–∏
            const headerRow = document.createElement('div');
            headerRow.className = 'box-header';
            headerRow.textContent = '';
            container.appendChild(headerRow);
            
            for (let i = 0; i < 16; i++) {
                const header = document.createElement('div');
                header.className = 'box-header';
                header.textContent = i.toString(16).toUpperCase();
                container.appendChild(header);
            }
            
            // –î–∞–Ω–Ω—ã–µ –±–æ–∫—Å–∞
            for (let i = 0; i < 16; i++) {
                const rowHeader = document.createElement('div');
                rowHeader.className = 'box-header';
                rowHeader.textContent = i.toString(16).toUpperCase();
                container.appendChild(rowHeader);
                
                for (let j = 0; j < 16; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'box-cell';
                    cell.textContent = box[i][j].toString(16).padStart(2, '0').toUpperCase();
                    cell.id = `box-cell-${i}-${j}`;
                    container.appendChild(cell);
                }
            }
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏
        function visualizeOperation(detail, operation) {
            const container = document.getElementById('operationVisualization');
            
            if (operation === 'encrypt') {
                container.innerHTML = `
                    <h4>üîí –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –±–∞–π—Ç–∞ #${detail.position}</h4>
                    <p>–ò—Å—Ö–æ–¥–Ω—ã–π: 0x${detail.original.toString(16).padStart(2, '0')}</p>
                    <p>–ü–æ—Å–ª–µ CBC: r=0x${detail.r.toString(16)}, c=0x${detail.c.toString(16)}</p>
                    <p>–ê—Ñ–∏–Ω–Ω–æ–µ: a=0x${detail.a.toString(16)}, b=0x${detail.b.toString(16)}</p>
                    <p>–ò–∑ –±–æ–∫—Å–∞: B=0x${detail.B.toString(16)}, C=0x${detail.C_val.toString(16)}</p>
                    <p>–†–µ–∑—É–ª—å—Ç–∞—Ç: 0x${detail.encrypted.toString(16).padStart(2, '0')}</p>
                `;
                
                highlightCell(detail.a, detail.b, 'transform');
                highlightCell((16 - detail.a) % 16, detail.b, 'B-value');
                highlightCell(detail.a, (16 - detail.b) % 16, 'C-value');
                
            } else if (operation === 'decrypt') {
                container.innerHTML = `
                    <h4>üîì –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –±–∞–π—Ç–∞ #${detail.position}</h4>
                    <p>–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π: 0x${detail.encrypted.toString(16).padStart(2, '0')}</p>
                    <p>–ù–∞–π–¥–µ–Ω–æ: a=0x${detail.a.toString(16)}, b=0x${detail.b.toString(16)}</p>
                    <p>–û–±—Ä–∞—Ç–Ω–æ–µ: r=0x${detail.r.toString(16)}, c=0x${detail.c.toString(16)}</p>
                    <p>–ü–æ—Å–ª–µ CBC: r=0x${detail.originalR.toString(16)}, c=0x${detail.originalC.toString(16)}</p>
                    <p>–†–µ–∑—É–ª—å—Ç–∞—Ç: 0x${detail.original.toString(16).padStart(2, '0')}</p>
                `;
                
                highlightCell(detail.a, detail.b, 'found-transform');
                highlightCell((16 - detail.a) % 16, detail.b, 'found-B');
                highlightCell(detail.a, (16 - detail.b) % 16, 'found-C');
            }
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–¥—Å–≤–µ—Ç–∫–∏ —è—á–µ–π–∫–∏
        function highlightCell(row, col, type) {
            const cell = document.getElementById(`box-cell-${row}-${col}`);
            if (cell) {
                cell.classList.add('highlight');
                cell.title = `–¢–∏–ø: ${type}, –ó–Ω–∞—á–µ–Ω–∏–µ: 0x${currentBox[row][col].toString(16).padStart(2, '0')}`;
            }
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ª–æ–≥–∞ –æ–ø–µ—Ä–∞—Ü–∏–π
        function updateOperationLog() {
            const logContainer = document.getElementById('operationLog');
            logContainer.innerHTML = '';
            
            operationLog.slice(0, 10).forEach((op, index) => {
                const opDiv = document.createElement('div');
                opDiv.textContent = `#${op.position}: 0x${op.original.toString(16).padStart(2, '0')} ‚Üí 0x${op.encrypted.toString(16).padStart(2, '0')}`;
                logContainer.appendChild(opDiv);
            });
            
            if (operationLog.length > 10) {
                const moreDiv = document.createElement('div');
                moreDiv.textContent = `... –∏ –µ—â—ë ${operationLog.length - 10} –æ–ø–µ—Ä–∞—Ü–∏–π`;
                moreDiv.style.color = '#fd79a8';
                logContainer.appendChild(moreDiv);
            }
        }
    </script>
</body>
</html>
