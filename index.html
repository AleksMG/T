<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TriFid Байтовый Шифратор</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        textarea, input[type="text"], button {
            width: 100%;
            padding: 10px;
            margin: 8px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        textarea {
            height: 100px;
            font-family: monospace;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        .visualization {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #e9ecef;
        }
        .box-grid {
            display: grid;
            grid-template-columns: repeat(17, 1fr);
            gap: 1px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 10px;
        }
        .box-header {
            text-align: center;
            font-weight: bold;
            padding: 3px;
            background: #e0e0e0;
        }
        .box-cell {
            padding: 3px;
            text-align: center;
            background: white;
            border: 1px solid #eee;
        }
        .highlight {
            background: #fff3cd !important;
            border: 1px solid #ffeaa7 !important;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            display: none;
        }
        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .processing {
            background: #cce5ff;
            color: #004085;
            border: 1px solid #b8daff;
        }
        .hex-view {
            font-family: monospace;
            word-break: break-all;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>TriFid Байтовый Шифратор</h1>
    <p>Адаптация алгоритма TriFid для работы с байтами using один бокс 16x16</p>

    <div class="container">
        <div class="panel">
            <h2>Шифрование</h2>
            <input type="text" id="encryptKey" placeholder="Ключевая фраза" value="секретный ключ">
            <textarea id="plainText" placeholder="Текст для шифрования">Пример текста для шифрования</textarea>
            <button onclick="encrypt()">Зашифровать</button>
            <div id="encryptStatus" class="status"></div>
            <div class="hex-view">Шифротекст (HEX): <span id="cipherHex"></span></div>
        </div>

        <div class="panel">
            <h2>Дешифрование</h2>
            <input type="text" id="decryptKey" placeholder="Ключевая фраза" value="секретный ключ">
            <textarea id="cipherText" placeholder="Шифротекст в HEX формате"></textarea>
            <button onclick="decrypt()">Дешифровать</button>
            <div id="decryptStatus" class="status"></div>
            <div class="hex-view">Результат: <span id="decryptedText"></span></div>
        </div>
    </div>

    <div class="panel">
        <h2>Визуализация бокса 16x16</h2>
        <p>Текущий ключ: <span id="currentKey"></span></p>
        <button onclick="updateVisualization()">Обновить визуализацию</button>
        <div id="boxVisualization" class="box-grid"></div>
        
        <h3>Последняя операция</h3>
        <div id="operationVisualization" class="visualization">
            <p>Выполните операцию шифрования/дешифрования для просмотра деталей</p>
        </div>
    </div>

    <script>
        // Глобальные переменные
        let currentBox = null;
        let currentKey = "";

        // Инициализация при загрузке
        window.onload = function() {
            updateVisualization();
        };

        // Функция для создания бокса на основе ключа
        function createBoxFromKey(key) {
            if (key === currentKey && currentBox !== null) {
                return currentBox;
            }
            
            currentKey = key;
            const box = new Array(16);
            
            // Создаем seed из ключа using HMAC-SHA256
            const encoder = new TextEncoder();
            const keyData = encoder.encode(key);
            
            // Используем HMAC для создания детерминированного seed
            const seed = new Uint8Array(32);
            for (let i = 0; i < keyData.length; i++) {
                seed[i % 32] ^= keyData[i];
            }
            
            // Заполняем бокс начальными значениями
            const tempArray = new Array(256);
            for (let i = 0; i < 256; i++) {
                tempArray[i] = i;
            }
            
            // Перемешиваем using Fisher-Yates с псевдослучайностью на основе ключа
            for (let i = 255; i > 0; i--) {
                const j = seed[i % 32] % (i + 1);
                [tempArray[i], tempArray[j]] = [tempArray[j], tempArray[i]];
            }
            
            // Заполняем 16x16 бокс
            for (let i = 0; i < 16; i++) {
                box[i] = new Array(16);
                for (let j = 0; j < 16; j++) {
                    box[i][j] = tempArray[i * 16 + j];
                }
            }
            
            currentBox = box;
            return box;
        }

        // Функция шифрования байта
        function encryptByte(byte, box, position) {
            const row = (byte >> 4) & 0x0F;
            const col = byte & 0x0F;
            
            // Добавляем позицию для усиления стойкости
            const posMod = position % 256;
            const modRow = (row + (posMod >> 4)) & 0x0F;
            const modCol = (col + (posMod & 0x0F)) & 0x0F;
            
            // Получаем значения с трех виртуальных этажей
            const a = box[modRow][modCol];
            const b = box[(15 - modRow + (posMod >> 4)) % 16][(modCol + (posMod & 0x0F)) % 16];
            const c = box[(modRow + (posMod & 0x0F)) % 16][(15 - modCol + (posMod >> 4)) % 16];
            
            // Формируем зашифрованный байт
            const encrypted = (b << 4) | (c & 0x0F);
            
            return {
                original: byte,
                encrypted: encrypted,
                row: modRow,
                col: modCol,
                values: {a, b, c}
            };
        }

        // Функция дешифрования байта
        function decryptByte(byte, box, position) {
            const targetB = (byte >> 4) & 0x0F;
            const targetC = byte & 0x0F;
            
            const posMod = position % 256;
            
            // Перебираем все возможные комбинации
            for (let r = 0; r < 16; r++) {
                for (let c = 0; c < 16; c++) {
                    // Учитываем позицию так же, как при шифровании
                    const modRow = (r + (posMod >> 4)) & 0x0F;
                    const modCol = (c + (posMod & 0x0F)) & 0x0F;
                    
                    const testB = box[(15 - modRow + (posMod >> 4)) % 16][(modCol + (posMod & 0x0F)) % 16];
                    const testC = box[(modRow + (posMod & 0x0F)) % 16][(15 - modCol + (posMod >> 4)) % 16];
                    
                    if (testB === targetB && testC === targetC) {
                        const original = (r << 4) | c;
                        return {
                            encrypted: byte,
                            original: original,
                            row: r,
                            col: c,
                            values: {b: targetB, c: targetC}
                        };
                    }
                }
            }
            
            return null;
        }

        // Основная функция шифрования
        function encrypt() {
            const key = document.getElementById('encryptKey').value;
            const text = document.getElementById('plainText').value;
            
            if (!key || !text) {
                showStatus('encryptStatus', 'error', 'Введите ключ и текст для шифрования');
                return;
            }
            
            showStatus('encryptStatus', 'processing', 'Шифрование...');
            
            setTimeout(() => {
                try {
                    const box = createBoxFromKey(key);
                    const encoder = new TextEncoder();
                    const data = encoder.encode(text);
                    const result = new Uint8Array(data.length);
                    const details = [];
                    
                    for (let i = 0; i < data.length; i++) {
                        const encryptionDetail = encryptByte(data[i], box, i);
                        result[i] = encryptionDetail.encrypted;
                        details.push(encryptionDetail);
                    }
                    
                    // Конвертируем в HEX строку
                    const hexResult = Array.from(result).map(b => b.toString(16).padStart(2, '0')).join('');
                    document.getElementById('cipherText').value = hexResult;
                    document.getElementById('cipherHex').textContent = hexResult;
                    
                    showStatus('encryptStatus', 'success', `Успешно зашифровано ${data.length} байт`);
                    visualizeOperation(details[0], 'encrypt');
                } catch (error) {
                    showStatus('encryptStatus', 'error', 'Ошибка при шифровании: ' + error.message);
                }
            }, 100);
        }

        // Основная функция дешифрования
        function decrypt() {
            const key = document.getElementById('decryptKey').value;
            const cipherHex = document.getElementById('cipherText').value;
            
            if (!key || !cipherHex) {
                showStatus('decryptStatus', 'error', 'Введите ключ и шифротекст');
                return;
            }
            
            // Проверяем HEX формат
            if (!/^[0-9a-fA-F]+$/.test(cipherHex) || cipherHex.length % 2 !== 0) {
                showStatus('decryptStatus', 'error', 'Неверный формат HEX данных');
                return;
            }
            
            showStatus('decryptStatus', 'processing', 'Дешифрование...');
            
            setTimeout(() => {
                try {
                    const box = createBoxFromKey(key);
                    // Конвертируем HEX строку в байты
                    const byteArray = [];
                    for (let i = 0; i < cipherHex.length; i += 2) {
                        byteArray.push(parseInt(cipherHex.substr(i, 2), 16));
                    }
                    
                    const result = new Uint8Array(byteArray.length);
                    const details = [];
                    
                    for (let i = 0; i < byteArray.length; i++) {
                        const decryptionDetail = decryptByte(byteArray[i], box, i);
                        if (decryptionDetail === null) {
                            throw new Error(`Не удалось дешифровать байт на позиции ${i}`);
                        }
                        result[i] = decryptionDetail.original;
                        details.push(decryptionDetail);
                    }
                    
                    // Конвертируем байты в текст
                    const decoder = new TextDecoder();
                    const textResult = decoder.decode(result);
                    document.getElementById('decryptedText').textContent = textResult;
                    
                    showStatus('decryptStatus', 'success', `Успешно дешифровано ${byteArray.length} байт`);
                    visualizeOperation(details[0], 'decrypt');
                } catch (error) {
                    showStatus('decryptStatus', 'error', 'Ошибка при дешифровании: ' + error.message);
                }
            }, 100);
        }

        // Функция для отображения статуса
        function showStatus(elementId, type, message) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = 'status ' + type;
            element.style.display = 'block';
        }

        // Функция для визуализации бокса
        function updateVisualization() {
            const key = document.getElementById('encryptKey').value || document.getElementById('decryptKey').value || 'секретный ключ';
            document.getElementById('currentKey').textContent = key;
            
            const box = createBoxFromKey(key);
            const container = document.getElementById('boxVisualization');
            container.innerHTML = '';
            
            // Заголовки столбцов
            const headerRow = document.createElement('div');
            headerRow.className = 'box-header';
            headerRow.textContent = '';
            container.appendChild(headerRow);
            
            for (let i = 0; i < 16; i++) {
                const header = document.createElement('div');
                header.className = 'box-header';
                header.textContent = i.toString(16).toUpperCase();
                container.appendChild(header);
            }
            
            // Данные бокса
            for (let i = 0; i < 16; i++) {
                const rowHeader = document.createElement('div');
                rowHeader.className = 'box-header';
                rowHeader.textContent = i.toString(16).toUpperCase();
                container.appendChild(rowHeader);
                
                for (let j = 0; j < 16; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'box-cell';
                    cell.textContent = box[i][j].toString(16).padStart(2, '0').toUpperCase();
                    cell.id = `box-cell-${i}-${j}`;
                    container.appendChild(cell);
                }
            }
        }

        // Функция для визуализации операции
        function visualizeOperation(detail, operation) {
            const container = document.getElementById('operationVisualization');
            
            if (operation === 'encrypt') {
                container.innerHTML = `
                    <h4>Шифрование байта:</h4>
                    <p>Исходный байт: 0x${detail.original.toString(16).padStart(2, '0').toUpperCase()} 
                    (row=${detail.row.toString(16).toUpperCase()}, col=${detail.col.toString(16).toUpperCase()})</p>
                    <p>Значения с этажей: 
                      a=0x${detail.values.a.toString(16).padStart(2, '0').toUpperCase()}, 
                      b=0x${detail.values.b.toString(16).padStart(2, '0').toUpperCase()}, 
                      c=0x${detail.values.c.toString(16).padStart(2, '0').toUpperCase()}
                    </p>
                    <p>Зашифрованный байт: 0x${detail.encrypted.toString(16).padStart(2, '0').toUpperCase()} 
                    (b<<4 | c)</p>
                `;
                
                // Подсвечиваем ячейки в боксе
                highlightCell(detail.row, detail.col, 'original');
                highlightCell((15 - detail.row) % 16, detail.col, 'b-value');
                highlightCell(detail.row, (15 - detail.col) % 16, 'c-value');
                
            } else if (operation === 'decrypt') {
                container.innerHTML = `
                    <h4>Дешифрование байта:</h4>
                    <p>Зашифрованный байт: 0x${detail.encrypted.toString(16).padStart(2, '0').toUpperCase()}</p>
                    <p>Найдены координаты: row=${detail.row.toString(16).toUpperCase()}, col=${detail.col.toString(16).toUpperCase()}</p>
                    <p>Исходный байт: 0x${detail.original.toString(16).padStart(2, '0').toUpperCase()}</p>
                `;
                
                highlightCell(detail.row, detail.col, 'found');
            }
        }

        // Функция для подсветки ячейки в боксе
        function highlightCell(row, col, type) {
            const cell = document.getElementById(`box-cell-${row}-${col}`);
            if (cell) {
                cell.classList.add('highlight');
                
                // Добавляем подсказку
                let title = '';
                if (type === 'original') title = 'Исходная позиция';
                else if (type === 'b-value') title = 'Значение b (2й этаж)';
                else if (type === 'c-value') title = 'Значение c (3й этаж)';
                else if (type === 'found') title = 'Найденная позиция';
                
                cell.title = title;
            }
        }
    </script>
</body>
</html>
