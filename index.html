<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TriFid с афинным преобразованием и CBC (Исправленная версия)</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            padding: 20px; 
            max-width: 1200px;
            margin: 0 auto;
            line-height: 1.6;
        }
        h1, h2 {
            color: #2c3e50;
        }
        .container { 
            display: flex; 
            gap: 20px; 
            margin-bottom: 20px; 
            flex-wrap: wrap;
        }
        .panel { 
            background: #f9f9f9; 
            padding: 20px; 
            border-radius: 10px; 
            flex: 1;
            min-width: 300px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        textarea, input, button, select { 
            width: 100%; 
            margin: 8px 0; 
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        textarea {
            min-height: 100px;
            font-family: monospace;
        }
        button { 
            background: #3498db; 
            color: white; 
            border: none; 
            cursor: pointer;
            font-weight: bold;
            padding: 12px;
            transition: background 0.3s;
        }
        button:hover {
            background: #2980b9;
        }
        .status { 
            padding: 10px; 
            margin: 10px 0; 
            border-radius: 5px; 
        }
        .success { 
            background: #d4edda; 
            color: #155724; 
            border: 1px solid #c3e6cb;
        }
        .error { 
            background: #f8d7da; 
            color: #721c24; 
            border: 1px solid #f5c6cb;
        }
        .info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .analysis {
            background: #fef9e7;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            border-left: 4px solid #f1c40f;
        }
        code {
            background: #f8f9fa;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <h1>TriFid с афинным преобразованием и CBC (Исправленная версия)</h1>
    
    <div class="info">
        <h3>Анализ алгоритма шифрования</h3>
        <p>Исходный алгоритм имел проблемы с обратимостью из-за:</p>
        <ul>
            <li>Некорректного поиска в функции дешифрования</li>
            <li>Неэффективного обратного афинного преобразования</li>
            <li>Потенциальных коллизий при комбинировании значений из S-бокса</li>
        </ul>
        <p>В исправленной версии эти проблемы решены с помощью предварительного вычисления обратного преобразования и улучшенной логики поиска.</p>
    </div>

    <div class="container">
        <div class="panel">
            <h2>Шифрование</h2>
            <input type="text" id="encryptKey" placeholder="Ключевая фраза" value="секретный ключ">
            <textarea id="plainText" placeholder="Текст для шифрования">Пример текста для шифрования</textarea>
            <select id="encryptMode">
                <option value="cbc">CBC режим</option>
                <option value="ecb">ECB режим</option>
            </select>
            <button onclick="encrypt()">Зашифровать</button>
            <div id="encryptStatus" class="status"></div>
            <div><strong>Шифротекст (HEX):</strong> <span id="cipherHex" style="word-break: break-all;"></span></div>
        </div>

        <div class="panel">
            <h2>Дешифрование</h2>
            <input type="text" id="decryptKey" placeholder="Ключевая фраза" value="секретный ключ">
            <textarea id="cipherText" placeholder="Шифротекст в HEX формате"></textarea>
            <select id="decryptMode">
                <option value="cbc">CBC режим</option>
                <option value="ecb">ECB режим</option>
            </select>
            <button onclick="decrypt()">Дешифровать</button>
            <div id="decryptStatus" class="status"></div>
            <div><strong>Результат:</strong> <span id="decryptedText" style="word-break: break-all;"></span></div>
        </div>
    </div>

    <div class="analysis">
        <h3>Глубокий анализ логики шифрования и обратимости</h3>
        
        <h4>1. Создание S-бокса на основе ключа</h4>
        <p>Алгоритм создает псевдослучайный S-бокс 16×16 на основе ключевой фразы с использованием детерминированного seed. Это обеспечивает, что один и тот же ключ будет генерировать одинаковый бокс для шифрования и дешифрования.</p>
        
        <h4>2. Афинное преобразование</h4>
        <p>Прямое преобразование: <code>(a, b) = (r*11 + c*7) mod 16, (c*13 + r*5) mod 16</code></p>
        <p>Для обеспечения обратимости необходимо, чтобы преобразование было биективным. В исправленной версии мы предварительно вычисляем обратное преобразование для всех возможных пар (a, b).</p>
        
        <h4>3. Режимы шифрования</h4>
        <p><strong>ECB режим</strong>: каждый байт шифруется независимо. Не обеспечивает достаточной безопасности для больших текстов.</p>
        <p><strong>CBC режим</strong>: добавляется зависимость от предыдущего зашифрованного блока и позиции байта, что повышает криптостойкость.</p>
        
        <h4>4. Процесс шифрования</h4>
        <p>Каждый байт разделяется на два полубайта (r, c). В режиме CBC они комбинируются с предыдущим зашифрованным байтом и позицией. Затем применяется афинное преобразование, и результат используется для поиска значений в S-боксе.</p>
        
        <h4>5. Процесс дешифрования</h4>
        <p>Для дешифрования находится соответствующая пара (a, b) в S-боксе, применяется обратное афинное преобразование, и затем отменяются CBC-преобразования.</p>
        
        <h4>6. Потенциальные уязвимости</h4>
        <p>Данный алгоритм является учебным и не должен использоваться для защиты действительно важных данных. Он уязвим к атакам по известному открытому тексту и не имеет достаточного криптоанализа.</p>
    </div>

    <script>
        // Глобальные переменные
        let currentBox = null;
        let currentKey = "";
        let inverseAffineMap = null;

        // Предварительное вычисление обратного афинного преобразования
        function precomputeInverseAffine() {
            const map = new Array(16);
            for (let a = 0; a < 16; a++) {
                map[a] = new Array(16);
                for (let b = 0; b < 16; b++) {
                    // Находим r, c для каждой пары (a, b)
                    for (let r = 0; r < 16; r++) {
                        for (let c = 0; c < 16; c++) {
                            const res = affineTransform(r, c);
                            if (res.a === a && res.b === b) {
                                map[a][b] = { r, c };
                                break;
                            }
                        }
                    }
                }
            }
            return map;
        }

        // Функция для создания бокса на основе ключа
        function createBoxFromKey(key) {
            if (key === currentKey && currentBox !== null) {
                return currentBox;
            }
            
            currentKey = key;
            const box = new Array(16);
            
            // Создаем детерминированный seed из ключа
            const encoder = new TextEncoder();
            const keyData = encoder.encode(key);
            const seed = new Uint8Array(32);
            
            for (let i = 0; i < keyData.length; i++) {
                seed[i % 32] ^= keyData[i];
            }
            
            // Заполняем бокс начальными значениями
            const tempArray = new Array(256);
            for (let i = 0; i < 256; i++) {
                tempArray[i] = i;
            }
            
            // Перемешиваем using Fisher-Yates
            for (let i = 255; i > 0; i--) {
                const j = (seed[i % 32] + seed[(i + 7) % 32] * 256) % (i + 1);
                [tempArray[i], tempArray[j]] = [tempArray[j], tempArray[i]];
            }
            
            // Заполняем 16x16 бокс
            for (let i = 0; i < 16; i++) {
                box[i] = new Array(16);
                for (let j = 0; j < 16; j++) {
                    box[i][j] = tempArray[i * 16 + j];
                }
            }
            
            currentBox = box;
            inverseAffineMap = precomputeInverseAffine();
            return box;
        }

        // Афинное преобразование (прямое)
        function affineTransform(r, c) {
            const a = (r * 11 + c * 7) % 16;
            const b = (c * 13 + r * 5) % 16;
            return { a, b };
        }

        // Обратное афинное преобразование (использует предварительно вычисленные значения)
        function inverseAffine(a, b) {
            if (inverseAffineMap && inverseAffineMap[a] && inverseAffineMap[a][b]) {
                return inverseAffineMap[a][b];
            }
            return { r: 0, c: 0 }; // fallback
        }

        // Функция шифрования байта
        function encryptByte(byte, box, position, prevCipher) {
            const mode = document.getElementById('encryptMode').value;
            
            // Разбиваем байт на полубайты
            let r = (byte >> 4) & 0x0F;
            let c = byte & 0x0F;
            
            // Добавляем зависимость от предыдущего зашифрованного байта и позиции
            if (mode === 'cbc') {
                r = (r ^ (prevCipher & 0x0F) ^ (position & 0x0F)) & 0x0F;
                c = (c ^ ((prevCipher >> 4) & 0x0F) ^ ((position >> 4) & 0x0F)) & 0x0F;
            }
            
            // Применяем афинное преобразование
            const { a, b } = affineTransform(r, c);
            
            // Берем значения из бокса
            const B = box[a][b];
            const C_val = box[15 - a][15 - b];
            
            // Формируем зашифрованный байт
            const encrypted = ((B & 0xF0) | (C_val & 0x0F)) & 0xFF;
            
            return encrypted;
        }

        // Функция дешифрования байта
        function decryptByte(byte, box, position, prevCipher) {
            const mode = document.getElementById('decryptMode').value;
            
            // Разбиваем зашифрованный байт
            const targetB = (byte >> 4) & 0x0F;
            const targetC = byte & 0x0F;
            
            // Ищем a и b такие, что:
            // Старшие 4 бита box[a][b] == targetB и 
            // Младшие 4 бита box[15-a][15-b] == targetC
            for (let a = 0; a < 16; a++) {
                for (let b = 0; b < 16; b++) {
                    const valB = box[a][b];
                    const valC = box[15 - a][15 - b];
                    
                    if (((valB >> 4) & 0x0F) === targetB && (valC & 0x0F) === targetC) {
                        // Нашли a и b, применяем обратное афинное преобразование
                        const { r, c } = inverseAffine(a, b);
                        
                        let originalR = r;
                        let originalC = c;
                        
                        // Убираем зависимость от предыдущего байта и позиции
                        if (mode === 'cbc') {
                            originalR = (r ^ (prevCipher & 0x0F) ^ (position & 0x0F)) & 0x0F;
                            originalC = (c ^ ((prevCipher >> 4) & 0x0F) ^ ((position >> 4) & 0x0F)) & 0x0F;
                        }
                        
                        const original = ((originalR << 4) | originalC) & 0xFF;
                        return original;
                    }
                }
            }
            
            // Если не нашли - возвращаем 0 как запасной вариант
            return 0;
        }

        // Основная функция шифрования
        function encrypt() {
            const key = document.getElementById('encryptKey').value;
            const text = document.getElementById('plainText').value;
            
            if (!key || !text) {
                showStatus('encryptStatus', 'error', 'Введите ключ и текст для шифрования');
                return;
            }
            
            try {
                const box = createBoxFromKey(key);
                const encoder = new TextEncoder();
                const data = encoder.encode(text);
                const result = new Uint8Array(data.length);
                let prevCipher = 0x55; // Initialization Vector
                
                for (let i = 0; i < data.length; i++) {
                    result[i] = encryptByte(data[i], box, i, prevCipher);
                    prevCipher = result[i];
                }
                
                const hexResult = Array.from(result).map(b => b.toString(16).padStart(2, '0')).join('');
                document.getElementById('cipherText').value = hexResult;
                document.getElementById('cipherHex').textContent = hexResult;
                
                showStatus('encryptStatus', 'success', `Успешно зашифровано ${data.length} байт`);
            } catch (error) {
                showStatus('encryptStatus', 'error', 'Ошибка при шифровании: ' + error.message);
                console.error(error);
            }
        }

        // Основная функция дешифрования
        function decrypt() {
            const key = document.getElementById('decryptKey').value;
            const cipherHex = document.getElementById('cipherText').value;
            
            if (!key || !cipherHex) {
                showStatus('decryptStatus', 'error', 'Введите ключ и шифротекст');
                return;
            }
            
            if (!/^[0-9a-fA-F]+$/.test(cipherHex) || cipherHex.length % 2 !== 0) {
                showStatus('decryptStatus', 'error', 'Неверный формат HEX данных');
                return;
            }
            
            try {
                const box = createBoxFromKey(key);
                const byteArray = [];
                for (let i = 0; i < cipherHex.length; i += 2) {
                    byteArray.push(parseInt(cipherHex.substr(i, 2), 16));
                }
                
                const result = new Uint8Array(byteArray.length);
                let prevCipher = 0x55; // Тот же IV
                
                for (let i = 0; i < byteArray.length; i++) {
                    result[i] = decryptByte(byteArray[i], box, i, prevCipher);
                    prevCipher = byteArray[i];
                }
                
                const decoder = new TextDecoder();
                const textResult = decoder.decode(result);
                document.getElementById('decryptedText').textContent = textResult;
                
                showStatus('decryptStatus', 'success', `Успешно дешифровано ${byteArray.length} байт`);
            } catch (error) {
                showStatus('decryptStatus', 'error', 'Ошибка при дешифровании: ' + error.message);
                console.error(error);
            }
        }

        // Функция для отображения статуса
        function showStatus(elementId, type, message) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = 'status ' + type;
        }
    </script>
</body>
</html>
