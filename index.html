<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TriFid с афинным преобразованием и CBC</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .container { display: flex; gap: 20px; margin-bottom: 20px; }
        .panel { background: #f5f5f5; padding: 20px; border-radius: 10px; flex: 1; }
        textarea, input, button { width: 100%; margin: 5px 0; padding: 8px; }
        button { background: #007bff; color: white; border: none; cursor: pointer; }
        .status { padding: 10px; margin: 10px 0; border-radius: 5px; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    <h1>TriFid с афинным преобразованием и CBC</h1>

    <div class="container">
        <div class="panel">
            <h2>Шифрование</h2>
            <input type="text" id="encryptKey" placeholder="Ключевая фраза" value="секретный ключ">
            <textarea id="plainText" placeholder="Текст для шифрования">Пример текста для шифрования</textarea>
            <select id="encryptMode">
                <option value="cbc">CBC режим</option>
                <option value="ecb">ECB режим</option>
            </select>
            <button onclick="encrypt()">Зашифровать</button>
            <div id="encryptStatus" class="status"></div>
            <div>Шифротекст (HEX): <span id="cipherHex"></span></div>
        </div>

        <div class="panel">
            <h2>Дешифрование</h2>
            <input type="text" id="decryptKey" placeholder="Ключевая фраза" value="секретный ключ">
            <textarea id="cipherText" placeholder="Шифротекст в HEX формате"></textarea>
            <select id="decryptMode">
                <option value="cbc">CBC режим</option>
                <option value="ecb">ECB режим</option>
            </select>
            <button onclick="decrypt()">Дешифровать</button>
            <div id="decryptStatus" class="status"></div>
            <div>Результат: <span id="decryptedText"></span></div>
        </div>
    </div>

    <script>
        // Глобальные переменные
        let currentBox = null;
        let currentKey = "";

        // Функция для создания бокса на основе ключа
        function createBoxFromKey(key) {
            if (key === currentKey && currentBox !== null) {
                return currentBox;
            }
            
            currentKey = key;
            const box = new Array(16);
            
            // Создаем детерминированный seed из ключа
            const encoder = new TextEncoder();
            const keyData = encoder.encode(key);
            const seed = new Uint8Array(32);
            
            for (let i = 0; i < keyData.length; i++) {
                seed[i % 32] ^= keyData[i];
            }
            
            // Заполняем бокс начальными значениями
            const tempArray = new Array(256);
            for (let i = 0; i < 256; i++) {
                tempArray[i] = i;
            }
            
            // Перемешиваем using Fisher-Yates
            for (let i = 255; i > 0; i--) {
                const j = (seed[i % 32] + seed[(i + 7) % 32] * 256) % (i + 1);
                [tempArray[i], tempArray[j]] = [tempArray[j], tempArray[i]];
            }
            
            // Заполняем 16x16 бокс
            for (let i = 0; i < 16; i++) {
                box[i] = new Array(16);
                for (let j = 0; j < 16; j++) {
                    box[i][j] = tempArray[i * 16 + j];
                }
            }
            
            currentBox = box;
            return box;
        }

        // Афинное преобразование (прямое)
        function affineTransform(r, c) {
            const a = (r * 11 + c * 7) % 16;
            const b = (c * 13 + r * 5) % 16;
            return { a, b };
        }

        // Обратное афинное преобразование
        function inverseAffine(a, b) {
            // Перебор всех возможных вариантов
            for (let r = 0; r < 16; r++) {
                for (let c = 0; c < 16; c++) {
                    const res = affineTransform(r, c);
                    if (res.a === a && res.b === b) {
                        return { r, c };
                    }
                }
            }
            return { r: 0, c: 0 }; // fallback
        }

        // Функция шифрования байта
        function encryptByte(byte, box, position, prevCipher) {
            const mode = document.getElementById('encryptMode').value;
            
            // Разбиваем байт на полубайты
            let r = (byte >> 4) & 0x0F;
            let c = byte & 0x0F;
            
            // Добавляем зависимость от предыдущего зашифрованного байта и позиции
            if (mode === 'cbc') {
                r = r ^ (prevCipher & 0x0F) ^ (position & 0x0F);
                c = c ^ ((prevCipher >> 4) & 0x0F) ^ ((position >> 4) & 0x0F);
            }
            
            // Применяем афинное преобразование
            const { a, b } = affineTransform(r, c);
            
            // ПРАВИЛЬНО берем значения из бокса (как в AES)
            const B = box[a][b]; // ← Полный байт из бокса!
            const C_val = box[15 - a][15 - b]; // ← Полный байт из бокса!
            
            // Формируем зашифрованный байт
            const encrypted = (B & 0xF0) | (C_val & 0x0F); // Комбинируем старшие и младшие биты
            
            return encrypted;
        }

        // Функция дешифрования байта
        function decryptByte(byte, box, position, prevCipher) {
            const mode = document.getElementById('decryptMode').value;
            
            // Разбиваем зашифрованный байт
            const targetB = (byte >> 4) & 0x0F; // Старшие 4 бита
            const targetC = byte & 0x0F; // Младшие 4 бита
            
            // Ищем a и b такие, что:
            // Старшие 4 бита box[a][b] == targetB и 
            // Младшие 4 бита box[15-a][15-b] == targetC
            for (let a = 0; a < 16; a++) {
                for (let b = 0; b < 16; b++) {
                    const valB = box[a][b];
                    const valC = box[15 - a][15 - b];
                    
                    if (((valB >> 4) & 0x0F) === targetB && (valC & 0x0F) === targetC) {
                        // Нашли a и b, применяем обратное афинное преобразование
                        const { r, c } = inverseAffine(a, b);
                        
                        let originalR = r;
                        let originalC = c;
                        
                        // Убираем зависимость от предыдущего байта и позиции
                        if (mode === 'cbc') {
                            originalR = r ^ (prevCipher & 0x0F) ^ (position & 0x0F);
                            originalC = c ^ ((prevCipher >> 4) & 0x0F) ^ ((position >> 4) & 0x0F);
                        }
                        
                        const original = (originalR << 4) | originalC;
                        return original;
                    }
                }
            }
            
            // Если не нашли - возвращаем 0 как запасной вариант
            return 0;
        }

        // Основная функция шифрования
        function encrypt() {
            const key = document.getElementById('encryptKey').value;
            const text = document.getElementById('plainText').value;
            
            if (!key || !text) {
                showStatus('encryptStatus', 'error', 'Введите ключ и текст для шифрования');
                return;
            }
            
            try {
                const box = createBoxFromKey(key);
                const encoder = new TextEncoder();
                const data = encoder.encode(text);
                const result = new Uint8Array(data.length);
                let prevCipher = 0x55; // Initialization Vector
                
                for (let i = 0; i < data.length; i++) {
                    result[i] = encryptByte(data[i], box, i, prevCipher);
                    prevCipher = result[i];
                }
                
                const hexResult = Array.from(result).map(b => b.toString(16).padStart(2, '0')).join('');
                document.getElementById('cipherText').value = hexResult;
                document.getElementById('cipherHex').textContent = hexResult;
                
                showStatus('encryptStatus', 'success', `Успешно зашифровано ${data.length} байт`);
            } catch (error) {
                showStatus('encryptStatus', 'error', 'Ошибка при шифровании: ' + error.message);
            }
        }

        // Основная функция дешифрования
        function decrypt() {
            const key = document.getElementById('decryptKey').value;
            const cipherHex = document.getElementById('cipherText').value;
            
            if (!key || !cipherHex) {
                showStatus('decryptStatus', 'error', 'Введите ключ и шифротекст');
                return;
            }
            
            if (!/^[0-9a-fA-F]+$/.test(cipherHex) || cipherHex.length % 2 !== 0) {
                showStatus('decryptStatus', 'error', 'Неверный формат HEX данных');
                return;
            }
            
            try {
                const box = createBoxFromKey(key);
                const byteArray = [];
                for (let i = 0; i < cipherHex.length; i += 2) {
                    byteArray.push(parseInt(cipherHex.substr(i, 2), 16));
                }
                
                const result = new Uint8Array(byteArray.length);
                let prevCipher = 0x55; // Тот же IV
                
                for (let i = 0; i < byteArray.length; i++) {
                    result[i] = decryptByte(byteArray[i], box, i, prevCipher);
                    prevCipher = byteArray[i];
                }
                
                const decoder = new TextDecoder();
                const textResult = decoder.decode(result);
                document.getElementById('decryptedText').textContent = textResult;
                
                showStatus('decryptStatus', 'success', `Успешно дешифровано ${byteArray.length} байт`);
            } catch (error) {
                showStatus('decryptStatus', 'error', 'Ошибка при дешифровании: ' + error.message);
            }
        }

        // Функция для отображения статуса
        function showStatus(elementId, type, message) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = 'status ' + type;
        }
    </script>
</body>
</html>
